//
//  Key_Test.m
//  Seekrit
//
//  Created by Jens Alfke on 8/25/14.
//  Copyright (c) 2014 Couchbase. All rights reserved.
//

#import <Cocoa/Cocoa.h>
#import <XCTest/XCTest.h>
#import "Key.h"
#import "curve_sigs.h"


@interface Key_Test : XCTestCase
@end

@implementation Key_Test
{
    PrivateKey* alice;
    PrivateKey* bob;
}

- (void)setUp {
    [super setUp];
    alice = [Key generateKeyPair];
    bob = [Key generateKeyPair];
    XCTAssert(alice.publicKey != nil);
    XCTAssert(bob.publicKey != nil);
}

- (void)testBox {
    NSLog(@"alice = %@  /  %@", alice.keyData, alice.publicKey.keyData);
    NSLog(@"bob   = %@  /  %@", bob.keyData, bob.publicKey.keyData);
    NSData* clear = [@"this is the cleartext message right here!" dataUsingEncoding: NSUTF8StringEncoding];
    NSLog(@"cleartext = %@", clear);
    RawNonce nonce = {0x01, 0x02, 0x03}; // rest all zeroes
    NSData* cipher = [alice encrypt: clear withNonce: nonce forRecipient: bob.publicKey];
    XCTAssert(cipher);
    NSLog(@"ciphertext= %@", cipher);

    NSData* decrypted = [bob decrypt: cipher withNonce: nonce fromSender: alice.publicKey];
    NSLog(@"decrypted = %@", decrypted);
    XCTAssertEqualObjects(decrypted, clear);
}

- (void) testRecoverPublicKey {
    PrivateKey* alice2 = [[PrivateKey alloc] initWithKeyData: alice.keyData];
    XCTAssertEqualObjects(alice2.publicKey.keyData, alice.publicKey.keyData);
}

- (void) testRawSignatures {
    RawKey pubkey, privkey;
    SecRandomCopyBytes(kSecRandomDefault, 32, privkey.bytes);
    privkey.bytes[0] &= 248;
    privkey.bytes[31] &= 63;
    privkey.bytes[31] |= 64;
    curve25519_keygen(pubkey.bytes, privkey.bytes);

    // Verify that Key classes derive the same public key from the same private:
    PrivateKey* privObj = [[PrivateKey alloc] initWithRawKey: privkey];
    PublicKey* pubObj = [[PublicKey alloc] initWithRawKey: pubkey];
    XCTAssertEqualObjects(privObj.publicKey.keyData, pubObj.keyData);

    uint8_t signature[64], random[64];
    SecRandomCopyBytes(kSecRandomDefault, 64, random);
    char msg[] = "this is the cleartext message right here!";
    XCTAssertEqual(curve25519_sign(signature, privkey.bytes, (void*)msg, strlen(msg), random), 0);

    XCTAssertEqual(curve25519_verify(signature, pubkey.bytes, (void*)msg, strlen(msg)), 0);

    // Test PublicKey verifying signature generated by C API:
    NSData* message = [NSData dataWithBytes: msg length: strlen(msg)];
    NSData* sigObj = [privObj sign: message];
    XCTAssertNotNil(sigObj);
    XCTAssertEqual(sigObj.length, 64u);
    XCTAssert([pubObj verifySignature: sigObj ofData: message]);
    XCTAssert([privObj.publicKey verifySignature: sigObj ofData: message]);

    // Test C API verifying signature created by PrivateKey:
}

- (void) testSignatures {
    NSLog(@"alice = %@  /  %@", alice.keyData, alice.publicKey.keyData);
    NSData* message = [@"this is the cleartext message right here!" dataUsingEncoding: NSUTF8StringEncoding];
    NSData* signature = [alice sign: message];
    XCTAssertNotNil(signature);
    XCTAssertEqual(signature.length, 64u);
    NSLog(@"Signature = %@", signature);

    XCTAssert([alice.publicKey verifySignature: signature ofData: message]);
}

- (void) testNonces {
    RawNonce n = {0};
    n.bytes[23] = 200;
    [PrivateKey incrementNonce: &n by: 1];
    XCTAssertEqual(n.bytes[23], 201);
    for (int i=0; i<23; i++)
        XCTAssertEqual(n.bytes[i], 0);

    [PrivateKey incrementNonce: &n by: 100];
    XCTAssertEqual(n.bytes[23], 45);
    XCTAssertEqual(n.bytes[22], 1);
    for (int i=0; i<22; i++)
        XCTAssertEqual(n.bytes[i], 0);

    [PrivateKey incrementNonce: &n by: -45];
    XCTAssertEqual(n.bytes[23], 0);
    XCTAssertEqual(n.bytes[22], 1);
    for (int i=0; i<22; i++)
        XCTAssertEqual(n.bytes[i], 0);

    memset(&n, 0, sizeof(n));
    [PrivateKey incrementNonce: &n by: -1];
    for (int i=0; i<24; i++)
        XCTAssertEqual(n.bytes[i], 255);
}

@end
